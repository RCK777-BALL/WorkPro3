/*
 * SPDX-License-Identifier: MIT
 */

import { z } from 'zod';

import normalizeTags from './utils/tagHelpers';

const objectId = z.string().min(1, 'Identifier is required');
const idempotencyKey = z.string().min(1, 'Idempotency key is required');
const metadataSchema = z.record(z.any()).optional();
const barcodeSchema = z.string().min(1, 'Barcode is required');
const nameSchema = z.string().trim().min(1, 'Name is required').max(120, 'Name is too long');
const skuSchema = z.string().trim().min(1, 'SKU is required').max(64, 'SKU must be 64 characters or fewer');
const codeSchema = z.string().trim().min(1, 'Code is required').max(64, 'Code must be 64 characters or fewer');
const nonNegativeNumber = z.number().min(0, 'Value cannot be negative');
const tagsSchema = z.array(z.string().trim().min(1)).optional().transform(normalizeTags);

export const partInputSchema = z.object({
  name: z.string().min(1, 'Name is required'),
  barcode: barcodeSchema.optional(),
  partNo: z.string().optional(),
  description: z.string().optional(),
  category: z.string().optional(),
  sku: z.string().optional(),
  partNumber: z.string().optional(),
  location: z.string().optional(),
  quantity: z.number().optional(),
  unitCost: z.number().optional(),
  cost: z.number().optional(),
  unit: z.string().optional(),
  minStock: z.number().optional(),
  minQty: z.number().optional(),
  maxQty: z.number().optional(),
  minLevel: z.number().optional(),
  maxLevel: z.number().optional(),
  reorderPoint: z.number().optional(),
  reorderQty: z.number().optional(),
  reorderThreshold: z.number().optional(),
  leadTime: z.number().optional(),
  autoReorder: z.boolean().optional(),
  vendorId: objectId.optional(),
  assetIds: z.array(objectId).optional(),
  pmTemplateIds: z.array(objectId).optional(),
  lastRestockDate: z.string().optional(),
  lastOrderDate: z.string().optional(),
  notes: z.string().optional(),
});

export const vendorInputSchema = z.object({
  name: z.string().min(1, 'Vendor name is required'),
  contactName: z.string().optional(),
  contactEmail: z.string().email().optional(),
  contactPhone: z.string().optional(),
  address: z.string().optional(),
  leadTimeDays: z.number().optional(),
  notes: z.string().optional(),
  preferredSkus: z.array(z.string()).optional(),
});

export const purchaseOrderInputSchema = z.object({
  vendorId: objectId,
  items: z
    .array(
      z.object({
        partId: objectId,
        quantity: z.number().positive('Quantity must be positive'),
        unitCost: z.number().optional(),
      }),
    )
    .min(1, 'At least one item is required'),
  notes: z.string().optional(),
  expectedDate: z.string().optional(),
  autoGenerated: z.boolean().optional(),
  poNumber: z.string().optional(),
});

export const locationInputSchema = z.object({
  store: z.string().min(1, 'Store is required'),
  room: z.string().optional(),
  bin: z.string().optional(),
  barcode: barcodeSchema.optional(),
});

export const stockAdjustmentSchema = z.object({
  stockItemId: objectId,
  delta: z.number(),
  reason: z.string().optional(),
});

export const receiveInventorySchema = z.object({
  partId: objectId,
  locationId: objectId,
  quantity: z.number().positive('Quantity must be positive'),
  idempotencyKey,
  metadata: metadataSchema,
});

export const issueInventorySchema = z.object({
  partId: objectId,
  locationId: objectId,
  quantity: z.number().positive('Quantity must be positive'),
  idempotencyKey,
  metadata: metadataSchema,
});

export const adjustInventorySchema = z.object({
  partId: objectId,
  locationId: objectId,
  delta: z.number().refine((value) => value !== 0, 'Delta must be non-zero'),
  idempotencyKey,
  metadata: metadataSchema,
});

export const transferInventorySchema = z.object({
  partId: objectId,
  fromLocationId: objectId,
  toLocationId: objectId,
  quantity: z.number().positive('Quantity must be positive'),
  idempotencyKey,
  metadata: metadataSchema,
});

export const stockCountSchema = z.object({
  partId: objectId,
  locationId: objectId,
  quantity: z.number().min(0, 'Quantity cannot be negative'),
  idempotencyKey,
  metadata: metadataSchema,
});

export const partDefinitionSchema = z.object({
  name: nameSchema,
  sku: skuSchema,
  barcode: barcodeSchema.optional(),
  description: z.string().max(1024).optional(),
  tags: tagsSchema,
  unit: z.string().max(32).optional(),
  unitCost: nonNegativeNumber.optional(),
  reorderPoint: nonNegativeNumber.optional(),
  reorderQty: nonNegativeNumber.optional(),
});

export const stockLocationSchema = z.object({
  name: nameSchema,
  code: codeSchema,
  parentId: objectId.optional(),
  barcode: barcodeSchema.optional(),
  tags: tagsSchema,
});

export const partStockSchema = z.object({
  partId: objectId,
  locationId: objectId,
  quantity: nonNegativeNumber,
  reserved: nonNegativeNumber.optional(),
  reorderPoint: nonNegativeNumber.optional(),
  reorderQty: nonNegativeNumber.optional(),
  unitCost: nonNegativeNumber.optional(),
  tags: tagsSchema,
});

export const inventoryMovementSchema = z.object({
  partId: objectId,
  locationId: objectId,
  partStockId: objectId.optional(),
  type: z.enum(['receive', 'issue', 'adjust', 'transfer', 'count']),
  quantity: nonNegativeNumber,
  unitCost: nonNegativeNumber.optional(),
  reason: z.string().max(256).optional(),
  idempotencyKey: idempotencyKey.optional(),
  metadata: metadataSchema,
  tags: tagsSchema,
});

export const reorderAlertSchema = z.object({
  partId: objectId,
  partStockId: objectId.optional(),
  quantityOnHand: nonNegativeNumber.optional(),
  reorderPoint: nonNegativeNumber.optional(),
  status: z.enum(['open', 'approved', 'skipped', 'resolved']).optional(),
});

export const purchaseOrderStatusSchema = z.object({
  status: z.enum(['pending', 'approved', 'ordered', 'received', 'closed']),
  receipts: z
    .array(
      z.object({
        partId: objectId,
        quantity: z.number().nonnegative(),
      }),
    )
    .optional(),
});

export const inventoryTransferSchema = z.object({
  partId: objectId,
  fromLocationId: objectId,
  toLocationId: objectId,
  quantity: z.number().positive('Quantity must be greater than zero'),
});

export const vendorPriceSchema = z.object({
  vendorId: objectId,
  partId: objectId,
  unitCost: z.number().nonnegative('Unit cost must be zero or greater'),
  currency: z.string().optional(),
  leadTimeDays: z.number().int().nonnegative().optional(),
  effectiveDate: z.string().optional(),
});

export const partReservationSchema = z.object({
  partId: objectId,
  workOrderId: objectId.optional(),
  quantity: z.number().positive('Reservation quantity must be greater than zero'),
  neededBy: z.string().optional(),
  notes: z.string().optional(),
});

export const receivingTransactionSchema = z.object({
  purchaseOrderId: objectId.optional(),
  partId: objectId,
  quantity: z.number().positive('Quantity must be positive'),
  unitCost: z.number().nonnegative('Unit cost must be zero or greater').optional(),
  locationId: objectId.optional(),
  receivedAt: z.string().optional(),
  reference: z.string().optional(),
});

export type PartInput = z.infer<typeof partInputSchema>;
export type VendorInput = z.infer<typeof vendorInputSchema>;
export type PurchaseOrderInput = z.infer<typeof purchaseOrderInputSchema>;
export type LocationInput = z.infer<typeof locationInputSchema>;
export type StockAdjustmentInput = z.infer<typeof stockAdjustmentSchema>;
export type ReceiveInventoryInput = z.infer<typeof receiveInventorySchema>;
export type IssueInventoryInput = z.infer<typeof issueInventorySchema>;
export type AdjustInventoryInput = z.infer<typeof adjustInventorySchema>;
export type TransferInventoryInput = z.infer<typeof transferInventorySchema>;
export type StockCountInput = z.infer<typeof stockCountSchema>;
export type PartDefinitionInput = z.infer<typeof partDefinitionSchema>;
export type StockLocationInput = z.infer<typeof stockLocationSchema>;
export type PartStockInput = z.infer<typeof partStockSchema>;
export type InventoryMovementInput = z.infer<typeof inventoryMovementSchema>;
export type ReorderAlertInput = z.infer<typeof reorderAlertSchema>;
export type PurchaseOrderStatusInput = z.infer<typeof purchaseOrderStatusSchema>;
export type InventoryTransferInput = z.infer<typeof inventoryTransferSchema>;
export type VendorPriceInput = z.infer<typeof vendorPriceSchema>;
export type PartReservationInput = z.infer<typeof partReservationSchema>;
export type ReceivingTransactionInput = z.infer<typeof receivingTransactionSchema>;
