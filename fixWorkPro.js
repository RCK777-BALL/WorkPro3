#!/usr/bin/env node
import fs from "fs";
import path from "path";
import { execSync } from "child_process";
import chalk from "chalk";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const args = process.argv.slice(2);
const mode = (args[0] || "all").toLowerCase();
const runBackend = mode === "all" || mode === "backend";
const runFrontend = mode === "all" || mode === "frontend";

function logInfo(message) {
  console.log(chalk.cyan(message));
}

function logStep(message) {
  console.log(chalk.yellow(message));
}

function logSuccess(message) {
  console.log(chalk.green(message));
}

function logWarn(message) {
  console.log(chalk.keyword("orange")(message));
}

function logError(message) {
  console.log(chalk.red(message));
}

function findExistingDir(names) {
  for (const name of names) {
    const candidate = path.join(__dirname, name);
    if (fs.existsSync(candidate) && fs.lstatSync(candidate).isDirectory()) {
      return candidate;
    }
  }
  return null;
}

function traverseDir(dir, handler) {
  if (!fs.existsSync(dir)) return;
  const entries = fs.readdirSync(dir, { withFileTypes: true });
  for (const entry of entries) {
    if (entry.name === "node_modules" || entry.name === ".git") continue;
    const fullPath = path.join(dir, entry.name);
    if (entry.isDirectory()) {
      traverseDir(fullPath, handler);
    } else if (/\.(cjs|mjs|js|ts)$/i.test(entry.name)) {
      handler(fullPath);
    }
  }
}

function convertCommonJsToEsModule(content) {
  let updated = content;

  updated = updated.replace(
    /const\s+\{\s*([^}]+?)\s*\}\s*=\s*require\(["']([^"']+)["']\);?/g,
    (_match, bindings, moduleName) => {
      const normalized = bindings
        .split(",")
        .map((part) => part.trim())
        .filter(Boolean)
        .join(", ");
      return `import { ${normalized} } from "${moduleName}";`;
    },
  );

  updated = updated.replace(
    /const\s+([A-Za-z0-9_$]+)\s*=\s*require\(["']([^"']+)["']\)\.([A-Za-z0-9_$]+);?/g,
    (_match, binding, moduleName, property) => `import { ${property} as ${binding} } from "${moduleName}";`,
  );

  updated = updated.replace(
    /const\s+([A-Za-z0-9_$]+)\s*=\s*require\(["']([^"']+)["']\);?/g,
    (_match, binding, moduleName) => `import ${binding} from "${moduleName}";`,
  );

  updated = updated.replace(/module\.exports\s*=\s*router\s*;/g, "export default router;");

  updated = updated.replace(
    /module\.exports\s*=\s*([A-Za-z0-9_$]+)\s*;/g,
    (_match, binding) => `export default ${binding};`,
  );

  updated = updated.replace(
    /module\.exports\s*=\s*\{([^}]+)\};?/g,
    (_match, body) => {
      const parts = body
        .split(",")
        .map((part) => part.trim())
        .filter(Boolean)
        .map((part) => part.replace(/\s+as\s+.+$/, ""));
      if (!parts.length) return "";
      return `export { ${parts.join(", ")} };`;
    },
  );

  updated = updated.replace(
    /exports\.([A-Za-z0-9_$]+)\s*=\s*/g,
    (_match, name) => `export const ${name} = `,
  );

  return updated;
}

function ensureRouterExport(content) {
  if (!/export\s+default\s+router/.test(content) && /const\s+router\s*=/.test(content)) {
    return `${content.replace(/\s+$/, "")}\n\nexport default router;\n`;
  }
  return content;
}

function ensurePlaceholder(content) {
  if (content.trim().length === 0) {
    return "// Placeholder generated by fixWorkPro to maintain module structure.\n";
  }
  return content;
}

function ensureCorsConfiguration(backendDir) {
  const corsSnippet = `app.use(cors({\n  origin: ["http://localhost:5173"],\n  credentials: true,\n  allowedHeaders: ["Content-Type","Authorization","x-tenant-id"],\n}));`;
  const serverCandidates = [
    path.join(backendDir, "server.ts"),
    path.join(backendDir, "server.js"),
    path.join(backendDir, "src", "server.ts"),
    path.join(backendDir, "src", "server.js"),
    path.join(backendDir, "index.ts"),
    path.join(backendDir, "index.js"),
  ];

  for (const candidate of serverCandidates) {
    if (!fs.existsSync(candidate)) continue;
    let content = fs.readFileSync(candidate, "utf8");
    let updated = content;

    if (!/import\s+cors\s+from\s+["']cors["']/.test(updated)) {
      if (/const\s+cors\s*=\s*require\(["']cors["']\);?/.test(updated)) {
        updated = updated.replace(
          /const\s+cors\s*=\s*require\(["']cors["']\);?/,
          "import cors from \"cors\";",
        );
      } else {
        const importBlock = updated.match(/(import[^;]+;\s*)+/);
        if (importBlock) {
          const insertIndex = importBlock[0].length;
          updated = `${updated.slice(0, insertIndex)}import cors from "cors";\n${updated.slice(insertIndex)}`;
        } else {
          updated = `import cors from "cors";\n${updated}`;
        }
      }
    }

    if (!updated.includes(corsSnippet)) {
      const anchor = /const\s+app\s*=\s*express\s*\(\s*\)\s*;/.exec(updated);
      if (anchor) {
        const insertPos = anchor.index + anchor[0].length;
        updated = `${updated.slice(0, insertPos)}\n${corsSnippet}\n${updated.slice(insertPos)}`;
      } else {
        updated = `${updated}\n${corsSnippet}\n`;
      }
    }

    if (updated !== content) {
      fs.writeFileSync(candidate, updated, "utf8");
    }
  }
}

function ensureBackendPackageScript(backendDir) {
  const packagePath = path.join(backendDir, "package.json");
  if (!fs.existsSync(packagePath)) return;
  const pkg = JSON.parse(fs.readFileSync(packagePath, "utf8"));
  pkg.scripts = pkg.scripts || {};
  const desired = "node ../fixWorkPro.js backend";
  if (pkg.scripts["fix:backend"] !== desired) {
    pkg.scripts["fix:backend"] = desired;
    fs.writeFileSync(packagePath, `${JSON.stringify(pkg, null, 2)}\n`, "utf8");
  }
}

function ensureFrontendPackageScript(frontendDir) {
  const packagePath = path.join(frontendDir, "package.json");
  if (!fs.existsSync(packagePath)) return;
  const pkg = JSON.parse(fs.readFileSync(packagePath, "utf8"));
  pkg.scripts = pkg.scripts || {};
  const desired = "node ../fixWorkPro.js frontend";
  let changed = false;
  if (pkg.scripts["fix:frontend"] !== desired) {
    pkg.scripts["fix:frontend"] = desired;
    changed = true;
  }
  const deps = pkg.dependencies || {};
  if (!deps.axios) {
    deps.axios = "^1.7.9";
    pkg.dependencies = deps;
    changed = true;
  }
  if (!deps["react-hot-toast"]) {
    deps["react-hot-toast"] = "^2.4.1";
    pkg.dependencies = deps;
    changed = true;
  }
  if (changed) {
    fs.writeFileSync(packagePath, `${JSON.stringify(pkg, null, 2)}\n`, "utf8");
  }
}

function ensureRootPackageScripts() {
  const packagePath = path.join(__dirname, "package.json");
  let pkg = { name: "workpro3", private: true, scripts: {} };
  if (fs.existsSync(packagePath)) {
    try {
      const parsed = JSON.parse(fs.readFileSync(packagePath, "utf8"));
      pkg = { ...parsed, scripts: { ...(parsed.scripts || {}) } };
    } catch (err) {
      logWarn("⚠️ Unable to parse root package.json, recreating scripts section.");
    }
  }
  let changed = false;
  if (pkg.type !== "module") {
    pkg.type = "module";
    changed = true;
  }
  if (pkg.private !== true) {
    pkg.private = true;
    changed = true;
  }
  const desiredScripts = {
    "fix:backend": "node fixWorkPro.js backend",
    "fix:frontend": "node fixWorkPro.js frontend",
    "fix:all": "node fixWorkPro.js all",
  };
  for (const [key, value] of Object.entries(desiredScripts)) {
    if (pkg.scripts[key] !== value) {
      pkg.scripts[key] = value;
      changed = true;
    }
  }

  if (!fs.existsSync(packagePath) || changed) {
    fs.writeFileSync(packagePath, `${JSON.stringify(pkg, null, 2)}\n`, "utf8");
  }
}

function ensureApiFile(frontendDir) {
  const libPath = path.join(frontendDir, "src", "lib", "api.ts");
  const utilsPath = path.join(frontendDir, "src", "utils", "api.ts");
  const targetPath = fs.existsSync(libPath)
    ? libPath
    : fs.existsSync(utilsPath)
      ? utilsPath
      : libPath;

  if (!fs.existsSync(targetPath)) {
    const template = `import axios from "axios";\n\nconst api = axios.create({\n  baseURL: import.meta.env.VITE_API_BASE_URL || "http://localhost:5010/api",\n  withCredentials: true,\n});\n\napi.interceptors.request.use((config) => {\n  const token = localStorage.getItem("token");\n  if (token) {\n    config.headers = config.headers ?? {};\n    config.headers.Authorization = \`Bearer ${token}\`;\n  }\n  return config;\n});\n\napi.interceptors.response.use(\n  (response) => response,\n  (error) => {\n    if (error.response?.status === 401) {\n      window.location.href = "/login";\n    }\n    return Promise.reject(error);\n  },\n);\n\nexport default api;\n`;
    fs.mkdirSync(path.dirname(targetPath), { recursive: true });
    fs.writeFileSync(targetPath, template, "utf8");
    return;
  }

  let content = fs.readFileSync(targetPath, "utf8");
  let updated = content;

  if (/import\.meta\.env\.VITE_API_URL/.test(updated)) {
    updated = updated.replace(/import\.meta\.env\.VITE_API_URL/g, "import.meta.env.VITE_API_BASE_URL");
  }

  if (!/baseURL:\s*import\.meta\.env\.VITE_API_BASE_URL/.test(updated)) {
    updated = updated.replace(
      /baseURL:\s*[^,]+/,
      "baseURL: import.meta.env.VITE_API_BASE_URL || \"http://localhost:5010/api\"",
    );
  }

  if (!/withCredentials:\s*true/.test(updated)) {
    updated = updated.replace(
      /axios\.create\(\{([\s\S]*?)\}\)/,
      (_match, body) => {
        const cleaned = body.includes("withCredentials")
          ? body.replace(/withCredentials:\s*false/g, "withCredentials: true")
          : `${body.trim()}\n  withCredentials: true,\n`;
        return `axios.create({${cleaned}})`;
      },
    );
  }

  if (!/interceptors\.request/.test(updated)) {
    updated = `${updated.trim()}\n\napi.interceptors.request.use((config) => {\n  const token = localStorage.getItem("token");\n  if (token) {\n    config.headers = config.headers ?? {};\n    config.headers.Authorization = \`Bearer ${token}\`;\n  }\n  return config;\n});\n`;
  }

  if (!/interceptors\.response/.test(updated)) {
    updated = `${updated.trim()}\n\napi.interceptors.response.use(\n  (response) => response,\n  (error) => {\n    if (error.response?.status === 401) {\n      window.location.href = "/login";\n    }\n    return Promise.reject(error);\n  },\n);\n`;
  }

  if (updated !== content) {
    fs.writeFileSync(targetPath, updated, "utf8");
  }
}

function ensureAuthContext(frontendDir) {
  const authPath = path.join(frontendDir, "src", "context", "AuthContext.tsx");
  const template = `import { createContext, useContext, useMemo, useState, type ReactNode } from "react";\n\ntype AuthContextValue = {\n  login: (email: string, password: string) => Promise<void>;\n  logout: () => void;\n  user: { email: string } | null;\n};\n\nconst AuthContext = createContext<AuthContextValue | undefined>(undefined);\n\nexport const AuthProvider = ({ children }: { children: ReactNode }) => {\n  const [user, setUser] = useState<AuthContextValue["user"]>(null);\n\n  const value = useMemo<AuthContextValue>(\n    () => ({\n      user,\n      login: async (email: string, password: string) => {\n        if (!email || !password) throw new Error("Missing credentials");\n        setUser({ email });\n      },\n      logout: () => setUser(null),\n    }),\n    [user],\n  );\n\n  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;\n};\n\nexport const useAuth = () => {\n  const context = useContext(AuthContext);\n  if (!context) throw new Error("useAuth must be used within an AuthProvider");\n  return context;\n};\n`;
  if (!fs.existsSync(authPath)) {
    fs.mkdirSync(path.dirname(authPath), { recursive: true });
    fs.writeFileSync(authPath, template, "utf8");
    return;
  }
  const content = fs.readFileSync(authPath, "utf8");
  if (!/export\s+const\s+AuthProvider/.test(content) || !/export\s+const\s+useAuth/.test(content)) {
    fs.writeFileSync(authPath, template, "utf8");
  }
}

function ensureLoginPage(frontendDir) {
  const loginPath = path.join(frontendDir, "src", "pages", "Login.tsx");
  const template = `import { FormEvent, useState } from "react";\nimport { useNavigate } from "react-router-dom";\nimport toast from "react-hot-toast";\n\nimport { useAuth } from "@/context/AuthContext";\n\nconst DEFAULT_EMAIL = "admin@cmms.com";\nconst DEFAULT_PASSWORD = "Password123!";\n\nexport default function Login() {\n  const [email, setEmail] = useState(DEFAULT_EMAIL);\n  const [password, setPassword] = useState(DEFAULT_PASSWORD);\n  const [loading, setLoading] = useState(false);\n  const navigate = useNavigate();\n  const { login } = useAuth();\n\n  const handleSubmit = async (event: FormEvent<HTMLFormElement>) => {\n    event.preventDefault();\n    setLoading(true);\n    try {\n      await login(email, password);\n      toast.success("Login successful!");\n      navigate("/dashboard");\n    } catch (error) {\n      const message =\n        (error as { response?: { data?: { message?: string } } }).response?.data?.message ||\n        (error instanceof Error ? error.message : "Login failed");\n      toast.error(message);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  return (\n    <div className="flex h-screen items-center justify-center bg-black">\n      <form onSubmit={handleSubmit} className="w-80 space-y-4 rounded-lg bg-zinc-900 p-6">\n        <h2 className="text-center text-lg font-medium text-white">Access your command center</h2>\n        <input\n          type="email"\n          value={email}\n          onChange={(event) => setEmail(event.target.value)}\n          className="w-full rounded bg-zinc-800 p-2 text-white"\n          placeholder="Email"\n          autoComplete="email"\n        />\n        <input\n          type="password"\n          value={password}\n          onChange={(event) => setPassword(event.target.value)}\n          className="w-full rounded bg-zinc-800 p-2 text-white"\n          placeholder="Password"\n          autoComplete="current-password"\n        />\n        <button\n          type="submit"\n          disabled={loading}\n          className="w-full rounded bg-indigo-600 p-2 text-white hover:bg-indigo-500 disabled:opacity-50"\n        >\n          {loading ? "Signing in..." : "Sign in"}\n        </button>\n      </form>\n    </div>\n  );\n}\n`;
  if (!fs.existsSync(loginPath)) {
    fs.mkdirSync(path.dirname(loginPath), { recursive: true });
    fs.writeFileSync(loginPath, template, "utf8");
    return;
  }
  const content = fs.readFileSync(loginPath, "utf8");
  if (!/useAuth/.test(content) || !/handle(Login|Submit)/.test(content)) {
    fs.writeFileSync(loginPath, template, "utf8");
  }
}

function ensureEnv(frontendDir) {
  const envPath = path.join(frontendDir, ".env");
  const required = {
    VITE_API_BASE_URL: "http://localhost:5010/api",
    VITE_APP_TITLE: "WorkPro CMMS",
  };
  const existing = {};
  if (fs.existsSync(envPath)) {
    const lines = fs.readFileSync(envPath, "utf8").split(/\r?\n/);
    for (const line of lines) {
      if (!line || /^\s*#/.test(line)) continue;
      const [key, ...rest] = line.split("=");
      if (!key) continue;
      existing[key.trim()] = rest.join("=").trim();
    }
  }
  let changed = false;
  for (const [key, value] of Object.entries(required)) {
    if (existing[key] !== value) {
      existing[key] = value;
      changed = true;
    }
  }
  if (changed || !fs.existsSync(envPath)) {
    const content = Object.entries(existing)
      .map(([key, value]) => `${key}=${value}`)
      .join("\n");
    fs.writeFileSync(envPath, `${content}\n`, "utf8");
  }
}

function ensureMainToaster(frontendDir) {
  const mainPath = path.join(frontendDir, "src", "main.tsx");
  if (!fs.existsSync(mainPath)) return;
  let content = fs.readFileSync(mainPath, "utf8");
  let updated = content;
  if (!/react-hot-toast/.test(updated)) {
    updated = updated.replace(
      /import\s+ReactDOM[^;]+;/,
      (match) => `${match}\nimport { Toaster } from "react-hot-toast";`,
    );
  }
  if (!/<Toaster/.test(updated)) {
    updated = updated.replace(
      /<AuthProvider>([\s\S]*?)<\/AuthProvider>/,
      (match, inner) => `<AuthProvider>${inner}\n      <Toaster position="top-right" />\n    </AuthProvider>`,
    );
  }
  if (updated !== content) {
    fs.writeFileSync(mainPath, updated, "utf8");
  }
}

function fixBackend() {
  const backendDir = findExistingDir(["Backend", "backend"]);
  if (!backendDir) {
    logWarn("⚠️ Backend folder not found; skipping backend repairs.");
    return;
  }

  const targets = ["routes", "controllers", "middleware"];
  for (const target of targets) {
    const folder = path.join(backendDir, target);
    traverseDir(folder, (filePath) => {
      const content = fs.readFileSync(filePath, "utf8");
      let updated = ensurePlaceholder(content);
      updated = convertCommonJsToEsModule(updated);
      if (filePath.includes(`${path.sep}routes${path.sep}`)) {
        updated = ensureRouterExport(updated);
      }
      if (updated !== content) {
        fs.writeFileSync(filePath, updated, "utf8");
      }
    });
  }

  ensureCorsConfiguration(backendDir);
  ensureBackendPackageScript(backendDir);
  logSuccess("✅ Backend validation complete.");
}

function fixFrontend() {
  const frontendDir = findExistingDir(["Frontend", "frontend"]);
  if (!frontendDir) {
    logWarn("⚠️ Frontend folder not found; skipping frontend repairs.");
    return;
  }

  ensureApiFile(frontendDir);
  ensureAuthContext(frontendDir);
  ensureLoginPage(frontendDir);
  ensureEnv(frontendDir);
  ensureMainToaster(frontendDir);
  ensureFrontendPackageScript(frontendDir);
  logSuccess("✅ Frontend validation complete.");
}

function autoSyncWithGit() {
  const gitDir = path.join(__dirname, ".git");
  if (!fs.existsSync(gitDir)) {
    logWarn("⚠️ Git repository not detected. Skipping auto-commit and push.");
    return null;
  }
  let status = "";
  try {
    status = execSync("git status --porcelain", { cwd: __dirname, encoding: "utf8" }).trim();
  } catch (err) {
    logWarn("⚠️ Unable to read git status. Skipping auto-sync.");
    return null;
  }
  if (!status) {
    logInfo("ℹ️ No changes detected; skipping auto-commit.");
    return null;
  }

  const branch = `auto-fix-${new Date().toISOString().replace(/[:.]/g, "-")}`;
  try {
    execSync("git add .", { cwd: __dirname, stdio: "inherit" });
    execSync('git commit -m "🛠 Auto-fix: Full CMMS repair"', { cwd: __dirname, stdio: "inherit" });
    execSync(`git checkout -b ${branch}`, { cwd: __dirname, stdio: "inherit" });
    execSync(`git push origin ${branch}`, { cwd: __dirname, stdio: "inherit" });
    try {
      const remoteUrl = execSync("git remote get-url origin", { cwd: __dirname, encoding: "utf8" })
        .trim()
        .replace(/\.git$/, "");
      logSuccess(`✅ Pushed auto-fix branch: ${remoteUrl}/tree/${branch}`);
    } catch (err) {
      logSuccess(`✅ Auto-fix branch pushed: ${branch}`);
    }
    return branch;
  } catch (err) {
    logError(`❌ Git auto-sync failed: ${err.message}`);
    return null;
  }
}

(function main() {
  logInfo("🔧 Scanning project...");
  const detected = runBackend && runFrontend ? "Backend + Frontend" : runBackend ? "Backend" : "Frontend";
  logInfo(`🎯 DETECTED: ${detected}`);
  logStep("🔧 Running repairs...");

  if (runBackend) {
    fixBackend();
    logSuccess("✅ Backend repaired");
  }

  if (runFrontend) {
    fixFrontend();
    logSuccess("✅ Frontend repaired");
  }

  ensureRootPackageScripts();
  const branch = autoSyncWithGit();
  if (branch) {
    logSuccess(`🚀 Auto-fix branch pushed: ${branch}`);
  }

  logSuccess("🎉 WorkPro3 CMMS fully operational!");
})();
